# Release notes
## Changes in 0.5.5
### Enhancements
* **Local constraints**: probably we want to define constraints applied to parameters 
  of a method. [10]
* **Support overloading methods with the same number of arguments**: Right now FSM/JCUnit
 doesn't support those methods. But it would be nice to have. [13]
* **Multi-threading support**: FSM/JCUnit treats each state in each FSM as an independent
 factor. Therefore it guarantees a fair coverage for multi-threading situation where
 Step. 1, client 1 requests op.A the server and at the same time client 2 requests Op.B,
 Step. 2, ...
 with relatively small number of test cases since you can use pairwise/t-wise technique
 as its test suite generation method. [14]
* **Handle a history of inputs to FSMs**: When we want to test output of FSM, we 
 sometimes want to build an expectation from a history of inputs.
 E.g., Suppose we want to test a StringBuilder, internal state is I only, but the output 
 of build (toString()) is determined by the inputs by the time the method is called (a history).
 Right now documentation is not sufficient. ```FSMParamTest.java``` is a usage example
 of this feature.[17]   

### Fixed bugs
* **Story objects are not refreshed**: Due to this issue, nested FSMs might not be 
  tested when there is more than one test method in a test class.[15]

# Future works
* **Coverage report**: generating test suite which covers all the possible value-pairs
  under complicated constraints is a very time consuming task. Instead, relying on
  random generation and assessing how much possible value pairs are covered might be
  more practical and good enough.[11]
* **Simplify test suite generation**: right now (Sep/2015), FSM/JCUnit chooses states
 not only events as factors. But, except for the first one, states should always be 
 determined by the previous state and an input symbol (event) given to the FSM.
 As discussed in [Introduction to Combinatorial Testing][4] (pp.119), in this situation
 we can exclude them during test suite generation from factors and after the process
 finishes we can append states determined by previous states and input to each test 
 case. By this optimization, we should be able to improve FSM/JCUnit's performance.[12]
* **AETG algorithm support**: IPO algorithm isn't good at handling constraints and
 test suite generation can be very time consuming because factors are sorted in 
 a difficult order for the algorithm. Probably AETG can handle the situation better 
 since it generates a complete tuple every time. [16]

# Known bugs and limitations
* **Performance**: Constraints generated by FSM/JCUnit are very complex and make
 IPO algorithm very slow. This might be mitigated by [this issue][16].

# References
* [10] "Issue-9:(FSM)Local constraints" (done)
* [11] "Issue-10:(FSM)Coverage report"
* [12] "Issue-11:(FSM)Simplify test suite generation" 
* [13] "Issue-12:(FSM)Support overloading methods with the same number of arguments" (done) 
* [14] "Issue-13:(FSM)Multi-threading support"
* [15] "Issue-14:(FSM)Ensure FSMUtils.resetStories is called before each test method is called every time"
* [16] "Issue-17:(FSM)Support AETG tuple generation algorithm"
* [17] "Issue-18:(FSM)Handle a history of inputs to FSMs" 

[10]: https://github.com/dakusui/jcunit/issues/9
[11]: https://github.com/dakusui/jcunit/issues/10
[12]: https://github.com/dakusui/jcunit/issues/11
[13]: https://github.com/dakusui/jcunit/issues/12
[14]: https://github.com/dakusui/jcunit/issues/13
[15]: https://github.com/dakusui/jcunit/issues/14
[16]: https://github.com/dakusui/jcunit/issues/17
[17]: https://github.com/dakusui/jcunit/issues/18