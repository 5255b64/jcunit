package com.github.dakusui.jcunit.generators.ipo;

import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import com.github.dakusui.enumerator.Combinator;
import com.github.dakusui.enumerator.Enumerator;
import com.github.dakusui.jcunit.generators.ipo.ValueTuple.Attr;
import com.github.dakusui.jcunit.generators.ipo.ValueTuple.ValueTriple;

/**
 * A class that describes the test space in which the test runs generated by
 * <code>IPO</code> class should cover.
 * 
 * @author hiroshi
 */
public class TestSpace {
  /**
   * The value domains. Each element of this field represents the domain of each
   * parameter.
   */
  Object[][] domains;

  /**
   * Creates an object of this class.
   * 
   * @param domains
   *          Domains of the parameters.
   */
  public TestSpace(Object[][] domains) {
    if (domains == null)
      throw new NullPointerException();
    if (domains.length < 2)
      throw new IllegalArgumentException();
    for (Object[] d : domains) {
      if (d == null)
        throw new NullPointerException();
    }
    this.domains = domains;
  }

  /**
   * Retruns a number of domains handled by this object.
   * 
   * @return A number of domains.
   */
  int numDomains() {
    return domains.length;
  }

  /**
   * Returns a domain for specified parameter by <code>i</code>
   * 
   * @param i
   *          ID of the parameters. The origin is 1, not 0.
   * @return The domain for Parameter Fi.
   */
  Object[] domainOf(int i) {
    if (i == 0)
      throw new IllegalArgumentException();
    return domains[i - 1];
  }

  /**
   * Returns nth value of parameter Fi.
   * 
   * @param i
   *          ID of the parameter Fi.
   * @param n
   *          index of the parameter Fi.
   * @return the nth value of parameter Fi.
   */
  Object value(int i, int n) {
    if (i == 0)
      throw new IllegalArgumentException();
    if (n == 0)
      throw new IllegalArgumentException();
    return domains[i - 1][n - 1];
  }

  public Object[][] domains() {
    return this.domains;
  }

  public Set<ValueTriple> createAllTriples() {
    Set<ValueTriple> ret = new HashSet<ValueTriple>();
    List<Integer> indexes = new LinkedList<Integer>();
    for (int i = 0; i < domains.length; i++) {
      indexes.add(i);
    }
    Enumerator<Integer> enumerator = new Combinator<Integer>(indexes, 3);
    for (List<Integer> attrIndexes : enumerator) {
      // //
      // map integers 0 from max to all possible patterns;
      long max = 1;
      for (int attrIndex : attrIndexes) {
        max *= domains[attrIndex].length;
      }
      assert max != 0;
      for (long i = 0; i < max; i++) {
        long locator = i;
        List<Attr> attrs = new LinkedList<Attr>();
        Collections.reverse(attrIndexes);
        for (int index : attrIndexes) {
          attrs.add(0, new Attr(index, domains[index][(int) locator
              % domains[index].length]));
          locator /= domains[index].length;
        }
        ret.add(new ValueTriple(attrs));
      }
    }
    return ret;
  }
}