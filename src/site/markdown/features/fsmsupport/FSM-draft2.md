# Modeling a FSM

```
Fig. a

    +-----+ cook(a1<a2) +--------+
    |     |------------>|        |-----+
    |  I  |             | Cooked |     |eat(b)
    |     |<------------|        |<----+
    +-----+   done      +--------+

```

If you model this state machine as a Java program, it would be like following.
You can consider that this is software under which tests generated by JCUnit are executed (SUT).

```java

    public class FlyingSpaghettiMonster {
      private String dish  = null;
      public String cook(int pasta, int sauce) {
        this.dish = pasta;
        return String.format("Cooking %s %s", pasta, sauce);
      }
    
      public String eat() {
        if (dish != null) {
          return String.format("%s is yummy!", this.dish);
        }
        throw new IllegalStateException();
      }
    
      public boolean isReady() {
        return dish != null;
      }
    }
  
```

How to test this?
By following paths on the FSM giving possible arguments?
Probably it's a good way, but programmers can make many mistakes. Like creating a hidden unintended state,
forgetting an initialization of a certain field only in a certain method, etc.
How to guarantee that the test suite has good or at least acceptable coverage?


# About FSMs
FSM is a finite state machine.

----
JCUnit's FSM support uses a 'modified' Mealy Machine as a basic model of SUT.
Mealy Machine is also known as a finite state transducer. [Wikipedia article](http://en.wikipedia.org/wiki/Mealy_machine)

We can consider a software system as a finite state machine, but in testing, outputs of it matter
and we must verify them.
So, simple FSM model, which doesn't have outputs is not enough powerful to describe the
specification of the system under test.

Since a Mealy machine has an output when a transition happens,
if we regard it an object, we can also regard the input alphabets Sigma as a set
of methods of the object.

But methods (or scenarios performed on a system) usually have some input parameters
and unless we have a way to define those parameters in the model, we cannot describe
an object to be tested.

The finite state machine discussed in this document is a bit different from a usual
Mealy machine. Each of its input alphabets are identified by a tuple of an action, which
 corresponds to a method name, and a list of arguments given to the method.


## Is FSM a model powerful enough?
Actually not.
Mealy Machine will be necessary.
Input/output/parameters

But in this document, if we call a model FSM, it refers to a Mealy machine.


## Mealy machine


```
    
    <Sigma, Gamma, S, s0, delta, omega>
    
    Sigma ...
    Gamma ...
    S     ...
    s0    ...
    delta ...
    omega ...
    
```

# Writing a test suite

Defining a specification of SUT.


## Defining states
To define states in FSM, the first step would be

```java

    public enum Spec implements FSMSpec<FlyingSpaghettiMonster> {
      @StateSpec I,
      @StateSpec COOKED
    }

```

Actually, you do not need to use ```enum``` to define a FSM spec, but just use normal class like this.
 
```java

    public class Spec implements FSMSpec<FlyingSpaghettiMonster> {
      @StateSpec public static final Spec I = new Spec() {},
      @StateSpec public static final Spec COOKED = new Spec() {}
    }


```


## Defining actions

```java

      @ActionSpec
      public Expectation<FlyingSpaghettiMonster> cook(FSM<FlyingSpaghettiMonster> fsm, String pasta, String sauce) {
        return FSMUtils.invalid();
      }
  
      @ActionSpec
      public Expectation<FlyingSpaghettiMonster> eat(FSM<FlyingSpaghettiMonster> fsm) {
        return FSMUtils.invalid();
      }

```

  /**
   * Fields annotated with {@code StateSpec} will be considered states of the FSM.
   * And they must be public, static, final fields, and typed by an enclosing class.
   * Otherwise errors will be reported by JCUnit framework.
   * In this example, {@code Spec} is an enclosing class of {@code I} and {@code COOKED}
   * and they are typed with {@code Spec} because it is a Java {@code enum}, whose
   * members are typed with it.
   * <p/>
   * Methods annotated with {@code ActionSpec} will be considered actions of the FSM.
   * And they must be public, returning {@code Expectation<SUT>}, taking arguments
   * which define the signature of the methods to be tested in the SUT.
   */
   
```java

    public enum Spec implements FSMSpec<FlyingSpaghettiMonster> {
       @StateSpec I {
        @Override
        public boolean check(FlyingSpaghettiMonster flyingSpaghettiMonster) {
          return flyingSpaghettiMonster.isReady();
        }
  
        @Override
        public Expectation<FlyingSpaghettiMonster> cook(FSM<FlyingSpaghettiMonster> fsm, String dish, String sauce) {
          Checks.checknotnull(fsm);
          return FSMUtils.valid(fsm, COOKED, CoreMatchers.startsWith("Cooking"));
        }
      },
      @StateSpec COOKED {
        @Override
        public boolean check(FlyingSpaghettiMonster flyingSpaghettiMonster) {
          return flyingSpaghettiMonster.isReady();
        }
  
        @Override
        public Expectation<FlyingSpaghettiMonster> eat(FSM<FlyingSpaghettiMonster> fsm) {
          return FSMUtils.valid(fsm, COOKED, CoreMatchers.containsString("yummy"));
        }
  
        @Override
        public Expectation<FlyingSpaghettiMonster> cook(FSM<FlyingSpaghettiMonster> fsm, String dish, String sauce) {
          Checks.checknotnull(fsm);
          return FSMUtils.valid(fsm, COOKED, CoreMatchers.startsWith("Cooking"));
        }
      },;
  
  
      @ParametersSpec
      public static final Object[][] cook = new Object[][] {
          { "spaghetti", "spaghettini" },
          { "peperoncino", "carbonara", "meat sauce" },
      };
  
      @ActionSpec
      public Expectation<FlyingSpaghettiMonster> cook(FSM<FlyingSpaghettiMonster> fsm, String pasta, String sauce) {
        return FSMUtils.invalid();
      }
  
      @ActionSpec
      public Expectation<FlyingSpaghettiMonster> eat(FSM<FlyingSpaghettiMonster> fsm) {
        return FSMUtils.invalid();
      }
    }
```
