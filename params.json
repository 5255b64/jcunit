{"name":"JCUnit","tagline":"A combinatorial testing framework on top of JUnit + Model-based testing. It makes your testing life a lot easier.","body":"# JCUnit\r\nJCUnit is a framework to perform combinatorial tests using 'pairwise'(or more generally 't-wise') \r\ntechnique.\r\nAbout what combinatorial testings are, articles below are useful as a starting point.\r\n\r\n* [All-pairs testing](http://en.wikipedia.org/wiki/All-pairs_testing)\r\n* [Introduction to Combinatorial Testing](http://mse.isri.cmu.edu/software-engineering/documents/faculty-publications/miranda/kuhnintroductioncombinatorialtesting.pdf)\r\n\r\nVery roughly to say, it's a technique to generate test cases with good 'coverage' \r\nwithout making the number of test cases explode.\r\n\r\n# First test with JCUnit\r\nBelow is JCUnit's most basic example 'QuadraticEquationSolver.java'.\r\nJust by running QuadraticEquationSolverTest.java as a usual JUnit test, JCUnit will \r\nautomatically generate test cases based on '@FactorField' annotations.\r\n\r\n## QuadraticEquationSolver program example\r\nTo understand JCUnit's functions, let's test 'QuadraticEquationSolver.java' program, which solves 'quadratic equations' using a formula.\r\nThe program contains some intentional bugs and unclear specifications (or behaviors).\r\nThe formula it uses is,\r\n\r\n```java\r\n\r\n    {x1, x2} = { (-b + Math.sqrt(b*b - 4*c*a)) / 2*a, (-b - Math.sqrt(b*b - 4*c*a)) / 2*a }\r\n\r\n```\r\n\r\nwhere {x1, x2} are the solutions of an equation, \r\n\r\n```java\r\n\r\n    a * x^2 + b * x + c = 0\r\n\r\n```\r\n\r\n### Maven coordinate\r\nFirst of all, you will need to link JCUnit to your project.\r\nBelow is a pom.xml fragment to describe jcunit's dependency.\r\nPlease add it to your project's pom.xml \r\n\r\n```xml\r\n\r\n    <dependency>\r\n      <groupId>com.github.dakusui</groupId>\r\n      <artifactId>jcunit</artifactId>\r\n      <version>0.5.1</version>\r\n    </dependency>\r\n    \r\n```\r\n\r\n### QuadraticEquationSolver.java (Main class, SUT)\r\n'QuadraticEquationSolver' is the SUT (Software under test) in this example.\r\nThe class provides a function to solve a quadratic equation using a quadratic formula and returns the solutions.\r\n\r\n```java\r\n\r\n    //QuadraticEquationSolver.java\r\n    public class QuadraticEquationSolver {\r\n      private final double a;\r\n      private final double b;\r\n      private final double c;\r\n    \r\n      public static class Solutions {\r\n        public final double x1;\r\n        public final double x2;\r\n    \r\n        public Solutions(double x1, double x2) {\r\n          this.x1 = x1;\r\n          this.x2 = x2;\r\n        }\r\n    \r\n        public String toString() {\r\n          return String.format(\"(%f,%f)\", x1, x2);\r\n        }\r\n      }\r\n    \r\n      public QuadraticEquationSolver(double a, double b, double c) {\r\n        this.a = a;\r\n        this.b = b;\r\n        this.c = c;\r\n      }\r\n    \r\n      public Solutions solve() {\r\n        return new Solutions(\r\n            (-b + Math.sqrt(b * b - 4 * c * a)) / (2 * a),\r\n            (-b - Math.sqrt(b * b - 4 * c * a)) / (2 * a)\r\n        );\r\n      }\r\n    }\r\n```\r\n\r\nDid you already notice the bugs that this program has?\r\n\r\n* It doesn't consider equations that do not have solutions in real.\r\n* If it's not a quadratic equation but a linear one, how should it behave?\r\n* Errors. How should it handle errors? To what extent error is acceptable?\r\n* Overflows. If b * b, 4 * c * a, etc become bigger than Double.MAX_VALUE (or \r\nsmaller than Double.MIN_VALUE), how should it handle them?\r\n* Shouldn't we set some limits for a, b, and c? Both to make errors small enough \r\nand prevent overflows from happening.\r\n* etc. (maybe)\r\n\r\nTry to find (and reproduce) these bugs using JCUnit and fix them.\r\n\r\n### QuadraticEquationSolverTest.java (Test)\r\nQuadraticEquationSolverTest1 is a test class for QuadraticEquationSolver class.\r\n\r\n```java\r\n\r\n    // QuadraticEquationSolverTest1.java\r\n    @RunWith(JCUnit.class)\r\n    public class QuadraticEquationSolverTest1 {\r\n        @FactorField\r\n        public int a;\r\n        @FactorField\r\n        public int b;\r\n        @FactorField\r\n        public int c;\r\n    \r\n        @Test\r\n        public void test() {\r\n            QuadraticEquationSolver.Solutions s = new QuadraticEquationSolver(a, b,\r\n                    c).solve();\r\n            assertEquals(0.0, a * s.x1 * s.x1 + b * s.x1 + c);\r\n            assertEquals(0.0, a * s.x2 * s.x2 + b * s.x2 + c);\r\n        }\r\n    }\r\n    \r\n```\r\n\r\nIf you run this test class, JCUnit generates about fifty test cases and run them.\r\nBy default, it generates the test cases by using 'all-pairs' technique.\r\n\r\n#Tips\r\n## Tip 1: Customizing domains of @FactorField annotated fields (1)\r\nJCUnit creates test cases by assigning a value, picked up from a hardcoded set of values defined for each type, to each '@FactorField' annotated field in a test class.\r\nFor example, if a member is annotated with '@FactorField' and its type is int, JCUnit will pick up a value from a set\r\n{1, 0, -1, 100, -100, Integer.MAX_VALUE, Integer.MIN_VALUE}.\r\nBut this set is just a 'default' and you can customize it by using (overriding) an 'xyzLevels' attribute of a '@FactorField' annotation, \r\nwhere 'xyz' is a primitive types.\r\n\r\n```java\r\n\r\n    @FactorField(intLevels = { 0, 1, 2, -1, -2, 100, -100, 10000, -10000 })\r\n    public int a;\r\n\r\n```\r\n\r\nAbove is an example of the use the 'intLevels' attribute.\r\n\r\n\r\n## Tip 2: Customizing domains of @FactorField annotated fields (2)\r\nBy using 'levelsProvider' parameter of '@FactorField' and creating a static method whose name is the same as the annotated field's name,\r\nyou can customize the domain of a certain field in a much more flexible way.\r\n\r\nThe method mustn't have any parameters and its return value must be an array of the field's type.\r\n\r\nBelow is the example for that sort of function.\r\n\r\n```java\r\n\r\n    @FactorField(levelsProvider = MethodLevelsProvider.class)\r\n\tpublic int a;\r\n\t\r\n\tpublic static int[] a() {\r\n\t\treturn new int[]{0, 1, 2};\r\n\t}\r\n\t\r\n```\r\n\r\nThe values returned by the method will be picked up and assigned to the field 'a' by the framework one by one.\r\nAnd you need to use 'levelsProvider' attribute when you are going to use non-primitive, non-enum, nor non-string values as levels for a factor.\r\n\r\n## Tip 3: Customizing the strength of t-wise testing.\r\nAdd parameter 'generator = @Generator(IPO2TestCaseGenerator.class)' explicitly to the '@TestCaseGeneration',\r\nannotation for 'QuadraticEquationSolverTest1.java' and set the first parameter, which represents a 'strength'. \r\n\r\n```java\r\n\r\n    @RunWith(JCUnit.class)\r\n    @TestCaseGeneration(\r\n            generator = @Generator(\r\n                    value = IPO2TestCaseGenerator.class,\r\n                    params = { @Param(\"3\") }))\r\n    public class QuadraticEquationSolverTest1 {\r\n```\r\n\r\nIn this example, the line\r\n\r\n```java\r\n\r\n    params = { @Param(\"3\") }))\r\n\r\n```\r\n\r\nconfigures the strength of the t-wise tests performed by JCUnit.\r\n\r\nAnd '@Param' annotation is a standard way to give a parameter to JCUnit plugins (excepting '@FactorField', which requires more conciseness). \r\nIt takes a string array as its 'value'(and remember that you can omit curly braces if there is only one element in the array). \r\nJCUnit internally translates those values accordingly.\r\n\r\n## Tip 4: Defining constraints.\r\nIn testings, we sometimes want to exclude a certain pair (, a triple, or a tuple) from the test cases since there are constraints in the test domain.\r\n\r\nFor example, suppose there is a software system which has 100 parameters and doesn't accept any larger value than 1,000 for parameter x1.\r\nAnd it validates all the parameters and immediately exits if any one of them is invalid at start up.\r\n\r\nCombinatorial testing is an effort to cover pairs (or tuples) with test cases as less as possible to find bugs which cannot be found by testing any single input parameter.\r\nIf a test case, which can possibly contain a lot of meaningful pairs, is revoked by a single parameter, it means the coverage of the test suite will be damaged. \r\nBelow are the links that would be helpful for understanding how much constraint managements are important in combinatorial testing area. \r\n\r\n* [Combinatorial test cases with constraints in software systems](http://ieeexplore.ieee.org/xpl/articleDetails.jsp?reload=true&arnumber=6221818)\r\n* [An Efficient Algorithm for Constraint Handling in Combinatorial Test Generation](http://ieeexplore.ieee.org/xpl/articleDetails.jsp?reload=true&arnumber=6569736)\r\n\r\n(Of course we want to test the behaviors on such illegal inputs. It will be discussed in the next tip.) \r\n\r\nFor this purpose, JCUnit has a mechanism called 'constraints manager'.\r\nTo use a constraint manager, you can do below\r\n\r\n```java\r\n\r\n    @RunWith(JCUnit.class)\r\n    @TestCaseGeneration(\r\n        constraint = @Constraint(\r\n            value = QuadraticEquationSolverTestX.CM.class ))\r\n    public class QuadraticEquationSolverTestX {\r\n    ...\r\n```\r\n\r\n'CM' is a name of inner class which implements 'ConstraintManager' interface and checks if a given tuple violates any constraints in the test domain or not.\r\nUnfortunately you cannot use anonymous classes because a value passed to an annotation as its parameter must be a constant and Java's anonymous classes cannot be one.\r\n\r\nIf you want to exclude test cases that violate a discriminant of the quadratic equation formula and also make sure the given equation is a quadratic, \r\nnot a linear, the definition of 'CM' would be\r\n \r\n```java\r\n\r\n    public static class CM extends ConstraintManagerBase {\r\n        @Override\r\n        public boolean check(Tuple tuple) throws JCUnitSymbolException {\r\n          if (!tuple.containsKey(\"a\") || !tuple.containsKey(\"b\") || !tuple\r\n              .containsKey(\"c\")) {\r\n            throw new UndefinedSymbol();\r\n          }\r\n          int a = (Integer) tuple.get(\"a\");\r\n          int b = (Integer) tuple.get(\"b\");\r\n          int c = (Integer) tuple.get(\"c\");\r\n          return a != 0 && b * b - 4 * c * a >= 0;\r\n        }\r\n    }\r\n```\r\n\r\n'ConstraintManagerBase' is a helper class that makes it easy to implement a ConstraintManager.\r\nAll that you need is overriding 'boolean check(Tuple)' method.\r\nIn case the passed tuple violates your constraints, make it return false.\r\nA test case is passed as a tuple, you need to use 'get' method of it to retrieve the value (level) of it.\r\n\r\n\"a\", \"b\", or \"c\" are the names of the fields annotated with '@FactorField'. JCUnit accesses them using 'reflection' techniques of Java.\r\nJCUnit avoids using tuples for which check method of the specified constraint manager returns 'false'.\r\n\r\n## Tip 5: Writing test cases for error handling (negative tests)\r\nThat being said, handling errors appropriately is another concern.\r\nA program must complain of invalid parameters in an appropriate way.\r\nAnd this characteristic is another aspect of software under test to be tested.\r\n\r\nYou can do it by overriding 'getViolations' method of a constraint manager and switching the verification procedures based on a test's 'sub-identifier'.\r\n\r\nFirst, by overriding method, return test cases that explicitly violate the constraint represented by the constraint manager class itself.\r\n\r\n```java\r\n\r\n    public static class CM extends ConstraintManagerBase {\r\n        @Override\r\n        public boolean check(Tuple tuple) throws JCUnitSymbolException {\r\n            ...\r\n        }\r\n        \r\n        @Override\r\n        public List<Tuple> getViolations() {\r\n            List<Tuple> ret = new LinkedList<Tuple>();\r\n            ret.add(createTestCase(\"a=0\", createTestCase(0, 1, 1)));\r\n            ret.add(createTestCase(\"b*b-4ca<0\", createTestCase(100, 1, 100)));\r\n            ret.add(createTestCase(\"nonsense 1=0\", createTestCase(0, 0, 1)));\r\n            return ret;\r\n        }\r\n        \r\n        private Tuple createTestCase(int a, int b, int c) {\r\n            return new Tuple.Builder().put(\"a\", a).put(\"b\", b).put(\"c\", c).build();\r\n        }\r\n    }\r\n```\r\n\r\nNow you enhance your test case so that it verifies the software under test behaves correctly in case invalid parameters are given.\r\nLet's assume that the SUT should return null if one of the parameters 'a', 'b', or 'c' is not valid. \r\n\r\n```java\r\n\r\n    @Test\r\n    public void test() {\r\n        if (\"a=0\".equals(desc.getSubIdentifier())) {\r\n          assertEquals(null, s);\r\n        } else if (\"b*b-4ca<0\".equals(desc.getSubIdentifier())) {\r\n          assertEquals(null, s);\r\n        } else if (\"nonsense 1=0\".equals(desc.getSubIdentifier())) {\r\n          assertEquals(null, s);\r\n        } else {\r\n            QuadraticEquationSolver.Solutions s = new QuadraticEquationSolver(a, b,\r\n                    c).solve();\r\n            assertEquals(0.0, a * s.x1 * s.x1 + b * s.x1 + c);\r\n            assertEquals(0.0, a * s.x2 * s.x2 + b * s.x2 + c);\r\n        }\r\n    }\r\n```\r\n\r\n## Tip 6: Filtering test cases\r\n\r\nFrom time to time, you want to disable/enable test cases in order to concentrate some among all of them.\r\n'@Precondition' notation is your friend in this use case.\r\n\r\nYou can define a method returning boolean and with no parameter like below,\r\n\r\n```java\r\n\r\n    @FactorField(intLevels = { 1, 2, 3 })\r\n    public int a;\r\n    \r\n    ...\r\n    \r\n    @Precondition\r\n    public boolean filterMethod() {\r\n      return this.a == 3;\r\n    }\r\n```\r\n\r\nBy defining such a method, you can disable test cases which result in the method's value false.\r\nIn the example above, test cases whose factor 'a' is non 3 will no longer be executed.\r\n\r\n## Tip 7: Executing test methods based on given conditions\r\n\r\nAlso you sometimes want to let JCUnit decide a certain test method should be executed \r\nbased on some conditions automatically.\r\n\r\nE.g, in case you are testing quadratic equation solver program, if a discriminant of a given\r\n equation is negative, you want to check if error handling is working correct, \r\n but probably you don't want to perform a test to check if the solutions are precise.\r\n Of course the value is non-negative, you don't need a test for error handling and \r\n do need a test for solutions' precision.\r\n\r\nFor this purpose, JCUnit provides another annotation '@When'.\r\nBelow is an example to illustrate how this feature should be used.\r\n\r\n```java\r\n\r\n    @Test\r\n    @When( \"discriminantIsNonNegative\" )\r\n    public void thenSolveQuadraticEquation() {\r\n      ...\r\n    }\r\n```\r\n\r\nJCUnit will invoke a method whose name is 'discriminantIsNonNegative' and iff its\r\nreturn value is true, this test method will be executed.\r\n\r\nIf the coefficients of an equation, i.e. factors of this test class, are a, b, and c, \r\nthe method would look like below. \r\n\r\n```java\r\n\r\n    public boolean discriminantIsNonNegative() {\r\n        return b * b - 4 * c * a >= 0;\r\n    }\r\n```\r\n\r\nIf you want to add another condition you can also do below. \r\n\r\n```java\r\n\r\n    @Test\r\n    @When( \"aIsNonZero&&discriminantIsNonNegative\" )\r\n    public void thenSolveQuadraticEquation() {\r\n        ...\r\n    }\r\n```\r\n\r\nIn this example, you are making sure that a is not zero AND the discriminant is non-negative\r\nbefore this method is executed.\r\n\r\nAlso you can do\r\n\r\n```java\r\n\r\n    @Test\r\n    @When( \"!discriminantIsNonNegative\" )\r\n    public void thenAnErrorWillBeReported() {\r\n        ....\r\n    }\r\n```\r\n\r\nAnd, to express 'OR', do\r\n\r\n```java\r\n\r\n    @Test\r\n    @When({\"!discriminantIsNonNegative\", \"!aIsNonZero\"})\r\n    public void thenAnErrorWillBeReported() {\r\n        ....\r\n    }\r\n```\r\n\r\nUnfortunately you cannot use parentheses as of now.\r\n\r\n## Tip 8: As a pairwise test generator\r\n\r\nBy creating a test method below, which just prints test case definition, you can use JCUnit as a pairwise (or t-wise) test case generator.\r\n\r\n```java\r\n\r\n    @Test\r\n    public void printTestCase() {\r\n        System.out.println(TupleUtils.toString(TestCaseUtils.toTestCase(this)));\r\n    }\r\n```\r\n\r\nThe output will be a text whose lines are JSON objects and look like,\r\n\r\n```\r\n{\"browser\":\"IE\",\"cpuClockInGHz\":1.5,\"edition\":\"Home Premium\",\"gramInMB\":128,\"hddSizeInGB\":100,\"ramInGB\":8}\r\n{\"browser\":\"IE\",\"cpuClockInGHz\":2.5,\"edition\":\"Enterprise\",\"gramInMB\":256,\"hddSizeInGB\":30,\"ramInGB\":1}\r\n{\"browser\":\"IE\",\"cpuClockInGHz\":3.0,\"edition\":\"Home Basic\",\"gramInMB\":512,\"hddSizeInGB\":50,\"ramInGB\":2}\r\n{\"browser\":\"Opera\",\"cpuClockInGHz\":1.5,\"edition\":\"Ultimate\",\"gramInMB\":512,\"hddSizeInGB\":20,\"ramInGB\":1}\r\n{\"browser\":\"Opera\",\"cpuClockInGHz\":2.0,\"edition\":\"Professional\",\"gramInMB\":256,\"hddSizeInGB\":50,\"ramInGB\":8}\r\n...\r\n```\r\n\r\nYou can refer to a following example for this use case. \r\n* [TestGen.java](https://github.com/dakusui/jcunit/tree/develop/src/test/java/com/github/dakusui/jcunit/examples/testgen/TestGen.java)\r\n\r\n## Tip 9: Modeling a finite state machine\r\n\r\nProbably your SUT might have a specification where users need to follow a certain \r\nmanner like \"1. You will initialize the object, 2. Now you can do A or B, 3.\r\nIf you did A in step 2, you can do A1, A2, or B1. Otherwise you can only do B1.\",\r\nand A, B, etc can take a few parameters respectively.\r\n\r\nYou might be able to write a constraint manager to describe this sort of specification\r\n but it would be very complicated, boring, and error prone task.\r\n \r\nJCUnit has a feature called \"FSM support\" and the detail and how to use it are \r\ndiscussed in a separate document. Please refer to [FSM/JCUnit](FSM-README.md) \r\n\r\n# Examples\r\nFor more examples, see\r\n\r\n* [Examples](https://github.com/dakusui/jcunit/tree/develop/src/test/java/com/github/dakusui/jcunit/examples/quadraticequation)\r\n\r\n\r\n\r\n# Copyright and license #\r\n\r\nCopyright 2013 Hiroshi Ukai.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this work except in compliance with the License.\r\nYou may obtain a copy of the License in the LICENSE file, or at:\r\n\r\n  [http://www.apache.org/licenses/LICENSE-2.0](http://www.apache.org/licenses/LICENSE-2.0)\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}