{"name":"JCUnit","tagline":"A combinatorial testing framework on top of JUnit. It makes your refactoring life lot easier.","body":"# JCUnit\r\nJCUnit is a framework to perform combinatorial tests using 'pairwise'(or more generaly 't-wise') technique.\r\nAbout what combinatorial testings are, an Wikipedia article below might be helpful as a starting point.\r\n* [All-pairs testing](http://en.wikipedia.org/wiki/All-pairs_testing)\r\n\r\n# For users of previous versions\r\nThank you for using JCUnit.\r\nIn this release, I have simplified JCUnit's interfaces and I had to remove some features like automatic regression tests, \r\nreporting, or writing tests as logical predicates.\r\nFurthermore, names and semantics of annotations were changed and basically JCUnit 0.3.0 (or later) isn't compatible with the previous versions anymore.\r\nAlthough the removed functions might be provided as a part of JCUnit's core library itself or JCUnit-extra library \r\n(and of course they will become more sophisticated) in future, they are not available at this moment.\r\nSo, if you need these features, please keep using the older version for the time being. \r\n\r\n# First test with JCUnit\r\nBelow is JCUnit's most basic example 'QuadraticEquationSolver.java'.\r\nJust by running QuadraticEquationSolverTest.java as a usual JUnit test, JCUnit will automatically generate test cases based on '@FactorLevels' annotations.\r\n\r\n## QuadraticEquationSolver program example\r\nTo understand JCUnit's functions, let's test 'QuadraticEquationSolver.java' program, which solves 'quadratic equations' using a formula.\r\nThe program contains some intentional bugs and unclear specifications (or behaviors).\r\nThe formula it uses is,\r\n\r\n```\r\n{x1, x2} =  { (-b + Math.sqrt(b*b - 4*c*a)) / 2*a, (-b - Math.sqrt(b*b - 4*c*a)) / 2*a }\r\n```\r\nwhere {x1, x2} are the solutions of an equation, \r\n```\r\na * x^2 + b * x + c = 0\r\n```\r\n\r\n### QuadraticEquationSolver.java (Main class, SUT)\r\n'QuadraticEquationSolver' is the SUT (Software under test) in this example.\r\nThe class provides a function to solve a quadratic equation using a quadratic formula and returns the solutions.\r\n\r\n```\r\npackage com.github.dakusui.jcunit.framework.examples.quadraticequation.session1;\r\n\r\npublic class QuadraticEquationSolver {\r\n  private final double a;\r\n  private final double b;\r\n  private final double c;\r\n\r\n  public static class Solutions {\r\n    public final double x1;\r\n    public final double x2;\r\n\r\n    public Solutions(double x1, double x2) {\r\n      this.x1 = x1;\r\n      this.x2 = x2;\r\n    }\r\n\r\n    public String toString() {\r\n      return String.format(\"(%f,%f)\", x1, x2);\r\n    }\r\n  }\r\n\r\n  public QuadraticEquationSolver(double a, double b, double c) {\r\n    this.a = a;\r\n    this.b = b;\r\n    this.c = c;\r\n  }\r\n\r\n  public Solutions solve() {\r\n    return new Solutions(\r\n        (-b + Math.sqrt(b * b - 4 * c * a)) / (2 * a),\r\n        (-b - Math.sqrt(b * b - 4 * c * a)) / (2 * a)\r\n    );\r\n  }\r\n}\r\n```\r\n\r\nDid you already notice the bugs that this program has?\r\n* It doesn't consider equations do not have solutions in real.\r\n* If it's not a quadratic equation but a linear one, how should it behave?\r\n* Errors. How should it handle errors? To what extent error is acceptable?\r\n* Overflows. If b * b, 4 * c * a, etc become bigger than Double.MAX_VALUE (or smaller than Double.MIN_VALUE), how should it handle it?\r\n* Shouldn't we set some limits for a, b, and c? Both to make errors small enough and prevent overflows happen.\r\n* etc. (maybe)\r\n\r\nTry to find (and reproduce) these bugs using JCUnit and fix them.\r\n\r\n### QuadraticEquationSolverTest.java (Test)\r\nQuadraticEquationSolverTest is a test class for QuadraticEquationSolver class.\r\n\r\n```\r\npackage com.github.dakusui.jcunit.framework.examples.quadraticequation.session1;\r\n\r\nimport com.github.dakusui.jcunit.core.JCUnit;\r\nimport com.github.dakusui.jcunit.core.factor.FactorField;\r\nimport com.github.dakusui.jcunit.framework.examples.quadraticequation.session1.QuadraticEquationSolver;\r\nimport org.junit.Test;\r\nimport org.junit.runner.RunWith;\r\n\r\nimport static junit.framework.Assert.assertEquals;\r\n\r\n@RunWith(JCUnit.class)\r\npublic class QuadraticEquationSolverTest1 {\r\n\t@FactorField\r\n\tpublic int a;\r\n\t@FactorField\r\n\tpublic int b;\r\n\t@FactorField\r\n\tpublic int c;\r\n\r\n\t@Test\r\n\tpublic void test() {\r\n\t\tQuadraticEquationSolver.Solutions s = new QuadraticEquationSolver(a, b,\r\n\t\t\t\tc).solve();\r\n\t\tassertEquals(0.0, a * s.x1 * s.x1 + b * s.x1 + c);\r\n\t\tassertEquals(0.0, a * s.x2 * s.x2 + b * s.x2 + c);\r\n\t}\r\n}\r\n```\r\n\r\n### Maven coordinate\r\nBelow is a pom.xml fragment to describe jcunit's dependency.\r\n\r\n```\r\n    <dependency>\r\n      <groupId>com.github.dakusui</groupId>\r\n      <artifactId>jcunit</artifactId>\r\n      <version>[0.3.0,]</version>\r\n    </dependency>\r\n```\r\n\r\n## Tip 1: Customizing domains of @FactorField annotated fields (1)\r\nBy default, JCUnit creates test cases by assigning a value, picked up from a hardcoded set of values defined for each type, to each '@FactorField' annotated field in a test class\r\nFor example, if a member is annotated with '@FactorField' and its type is int, JCUnit will pick up a value from a set\r\n{1, 0, -1, 100, -100, Integer.MAX_VALUE, Integer.MIN_VALUE}.\r\nBut this set is just a 'default' and you can customize it by using (overriding) an 'xyzLevels' attribute of a '@FactorField' annotation, \r\nwhere 'xyz' is a primitive types.\r\n\r\n```\r\n  @FactorField(intLevels = { 0, 1, 2, -1, -2, 100, -100, 10000, -10000 })\r\n  public int a;\r\n```\r\n\r\nBelow is an example of using the 'intLevels' attribute.\r\n\r\n\r\n## Tip 2: Customizing domains of @FactorField annotated fields (2)\r\nBy using 'levelsFactory' parameter of '@FactorField' and creating a static method whose name is the same as the annotated field's name,\r\nyou can customize the domain of a certain field in a much more flexible way.\r\n\r\nThe method mustn't have any parameters and its return value must be an array of the field's type.\r\n\r\nBelow is the example for that sort of function.\r\n\r\n```\r\n    @FactorField(levelsFactory = MethodLevelsFactory.class)\r\n\tpublic int a;\r\n\t\r\n\tpublic static int[] a() {\r\n\t\treturn new int[]{0, 1, 2};\r\n\t}\r\n\t\r\n```\r\n\r\nThe values returned by the method will be picked up and assigned to the field 'a' by the framework one by one.\r\nAnd you need to use 'levelsFactory' attribute when you are going to use non-primitive, non-enum, nor non-string values as levels for a factor.\r\n\r\n## Tip 3: Customizing the strength of t-wise testing.\r\nAdd parameter 'generator = @Generator(IPO2TestCaseGenerator.class)' explicitly to the '@TestCaseGeneration',\r\nannotation for 'QuadraticEquationSolverTest1.java' and set the first parameter, which represents a 'strength'. \r\n\r\n```\r\n@RunWith(JCUnit.class)\r\n@TestCaseGeneration(\r\n\t\tgenerator = @Generator(\r\n\t\t\t\tvalue = IPO2TestCaseGenerator.class,\r\n\t\t\t\tparams = {\r\n\t\t\t\t\t\t@Param(type = Param.Type.Int, array = false, value = {\"3\"})\r\n\t\t\t\t}))\r\npublic class QuadraticEquationSolverTest1 {\r\n```\r\n\r\nIn this example, the line\r\n```\r\n\t@Param(type = Param.Type.Int, array = false, value = {\"3\"})\r\n```\r\nconfigures the strength of the t-wise tests performed by JCUnit.\r\nAnd '@Param' annotation is a standard way to give a parameter to JCUnit (excepting '@FactorLevels', \r\nwhich requires more conciseness). It looks a bit complicated, but is straightforward actually.\r\n\r\n'type' attribute tells JCUnit the type of the parameter,\r\n```\r\n\ttype = Param.Type.Int,\r\n```\r\n'array' attribute whether it's a array field or a non-array field.\r\n\r\n```\r\n\tarray = false, \r\n```\r\n\r\nand 'value' attribute is for actual data content to be passed to JCUnit.\r\n\r\n```\r\n    value = {\"3\"})\r\n```\r\n\r\nEven if the value is a non-array value, you need to have braces surrounding the value.\r\nAnd the values need to be strings, even if they are numbers like int, double, and so on.\r\nIn other words, 'value' is given as an array of string(s), and the type (including \r\nwhether it is an array or not) is given by 'type' and 'array' attributes. \r\n\r\n## Tips 4: Defining constraints.\r\nIn testings, we sometimes want to exclude a certain pair (, a triple, or a tuple) from the test cases since there are constraints in the test domain.\r\nFor example, suppose there is a software system which has 100 parameters and doesn't accept any larger value than 1,000 for parameter x1.\r\nAnd it validates all the parameters and immediately exits if any one of them is invalid at start up.\r\nSince combinatorial testing is an effort to cover pairs (or tuples) with test cases as less as possible to find bugs which cannot be found by testing any single input parameter,\r\nif a test case, which can possibly contain a lot of meaningful pairs, is revoked by such an error, which can be cause by just one parameter, it means the coverage of the test suite is severely reduced. \r\nBelow are the links that would be helpful for understanding how much constraint managements are important in combinatorial testing area. \r\n\r\n* [Combinatorial test cases with constraints in software systems](http://ieeexplore.ieee.org/xpl/articleDetails.jsp?reload=true&arnumber=6221818)\r\n* [An Efficient Algorithm for Constraint Handling in Combinatorial Test Generation](http://ieeexplore.ieee.org/xpl/articleDetails.jsp?reload=true&arnumber=6569736)\r\n\r\nFor this purpose, JCUnit has a mechanism called 'constraints manager'.\r\nTo use a constraint manager, you can do below\r\n\r\n```\r\n@RunWith(JCUnit.class)\r\n@TestCaseGeneration(\r\n    constraint = @Constraint(\r\n        value = QuadraticEquationSolverTestX.CM.class ))\r\npublic class QuadraticEquationSolverTestX {\r\n    ...\r\n```\r\n\r\n'CM' is a name of inner class which implements 'ConstraintManager' interface and checks if a given tuple violates any constraints in the test domain or not.\r\nUnfortunately you cannot use anonymous classes because a value passed to an annotation as its parameter must be a constant and Java's anonymous classes cannot be one.\r\nAnd if you want to exclude test cases that violate a discriminant of the quadratic equation formula and also make sure the given equation is a quadratic, \r\nnot a linear, the definition of 'CM' would be\r\n \r\n```\r\n  public static class CM extends ConstraintManagerBase {\r\n    @Override\r\n    public boolean check(Tuple tuple) throws JCUnitSymbolException {\r\n      if (!tuple.containsKey(\"a\") || !tuple.containsKey(\"b\") || !tuple\r\n          .containsKey(\"c\")) {\r\n        throw new JCUnitSymbolException();\r\n      }\r\n      int a = (Integer) tuple.get(\"a\");\r\n      int b = (Integer) tuple.get(\"b\");\r\n      int c = (Integer) tuple.get(\"c\");\r\n      return a != 0 && b * b - 4 * c * a >= 0;\r\n    }\r\n  }\r\n```\r\n\r\n'ConstraintManagerBase' is a helper class that makes it easy to implement a ConstraintManager.\r\nAll that you need is overriding 'boolean check(Tuple)' method.\r\nSince a test case is passed as a tuple, you need to use 'get' method of it.\r\n\"a\", \"b\", or \"c\" are the names of the field annotated with '@FactorField'. JCUnit accesses them using 'reflection' techniques of Java.\r\nJCUnit avoids using tuples for which check method of the specified constraint manager returns 'false'.\r\n\r\n# Tips 5: Writing test cases for error handling\r\nThat being said, handling errors appropriately is another concern.\r\nA program must complain of invalid parameters in an appropriate way, if given.\r\nAnd this characteristic is an aspect of software under test to be tested.\r\n\r\nYou can do it be overriding 'getViolations' method of a constraint manager and switching the\r\nverification procedures based on a test's 'sub-identifier'.\r\n\r\nFirst, by overriding method, return test cases that explicitly violate the constraint represented by the constraint manager class itself.\r\n\r\n```\r\n  public static class CM extends ConstraintManagerBase {\r\n    @Override\r\n    public boolean check(Tuple tuple) throws JCUnitSymbolException {\r\n        ...\r\n    }\r\n\r\n    @Override\r\n    public List<Violation> getViolations() {\r\n      List<Violation> ret = new LinkedList<Violation>();\r\n      ret.add(createViolation(\"a=0\", createTestCase(0, 1, 1)));\r\n      ret.add(createViolation(\"b*b-4ca<0\", createTestCase(100, 1, 100)));\r\n      ret.add(createViolation(\"nonsense 1=0\", createTestCase(0, 0, 1)));\r\n      return ret;\r\n    }\r\n\r\n    private Tuple createTestCase(int a, int b, int c) {\r\n      return new Tuple.Builder().put(\"a\", a).put(\"b\", b).put(\"c\", c).build();\r\n    }\r\n  }\r\n```\r\n\r\nThe method 'createViolation' is a helper method defined in 'ConstraintManagerBase', that returns a new 'Violation' object.\r\nThe first parameter to it can be any 'Serializable' object, which means you can use a string, \r\nan enum, int, short, or whatever an object which implements a 'Serializable' interface.\r\nYou will use these objects in order to identify which test procedure should be applied.\r\n\r\nNow you enhance your test case so that it verifies the software under test behaves correctly in case invalid parameters are given.\r\nLet's assume that the SUT should return null if one of the parameters 'a', 'b', or 'c' is not valid. \r\n\r\n```\r\n\t@Test\r\n\tpublic void test() {\r\n        if (\"a=0\".equals(desc.getSubIdentifier())) {\r\n          assertEquals(null, s);\r\n        } else if (\"b*b-4ca<0\".equals(desc.getSubIdentifier())) {\r\n          assertEquals(null, s);\r\n        } else if (\"nonsense 1=0\".equals(desc.getSubIdentifier())) {\r\n          assertEquals(null, s);\r\n        } else {\r\n            QuadraticEquationSolver.Solutions s = new QuadraticEquationSolver(a, b,\r\n                    c).solve();\r\n            assertEquals(0.0, a * s.x1 * s.x1 + b * s.x1 + c);\r\n            assertEquals(0.0, a * s.x2 * s.x2 + b * s.x2 + c);\r\n\t\t}\r\n\t}\r\n```\r\n\r\n# Copyright and license #\r\n\r\nCopyright 2013 Hiroshi Ukai.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this work except in compliance with the License.\r\nYou may obtain a copy of the License in the LICENSE file, or at:\r\n\r\n  [http://www.apache.org/licenses/LICENSE-2.0](http://www.apache.org/licenses/LICENSE-2.0)\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}