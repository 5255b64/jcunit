# Introduction
FSM support of JCUnit (FSM/JCUnit) offers you automated 'Model-based testing' functionality. 
The basic idea is to let users model their SUT(System under test)s as finite state 
machines and the other things should be taken care of by computers.

Following is a diagram picked up from a Wikipedia article about [Model-based testing][0] that
illustrates a pipeline of "Offline test case generation". Activities executed by 
JCUnit and artifacts generated by JCUnits are annotated in it.  

Users are supposed to provide 3 types of information. Model, test requirements,
and IXIT, which stands for "Implementation extra information".

[Fig 0. Model-based testing pipeline and JCUnit's process]
```

                                   (1)User
                         +---------------+
                         |     Model     |
                         +---------------+
                                 |
                (2)User          V  JCUnit
    +-----------------+  +---------------+ 
    |Test requirements|->|Test derivation|
    +-----------------+  +---------------+ 
                                 |
                                 V   
                       +-------------------+
                       |Abstract test suite|(internal data generated by JCUnit)
                       +-------------------+
                                 |
     (3)User                     V            JCUnit
    +------+     +---------------------------------+
    | IXIT |---->|Executable test suite compilation|
    +------+     +---------------------------------+
                                 |
                                 V
                       +---------------------+
                       |Executable test suite|(internal data generated by JCUnit)
                       +---------------------+
                                 |
                                 V  JCUnit
                          +--------------+
                          |Test execution|
                          +--------------+
                                 |
                                 V
                          +--------------+
                          |    Reports   |(Generated by JCUnit)
                          +--------------+
     
```

The rest of this document consists of following sections.

+ **Modeling FSM**: In this section, it will be discussed how to model your SUT
  as FSM in JCUnit.((1) in the diagram)
+ **Running tests**: How to define 'test requirements'(how should test cases be
 generated, etc) and 'IXIT'(how should SUT be set up before starting each test case,
 etc) in JCUnit will be discussed in this section. ((2) and (3) in the diagram)
+ **Inside FSM/JCUnit**: The mechanism of FSM support will be discussed in this
section.
+ **Advanced techniques**: More practical techniques, e.g., how to test 2 FSMs at the same time 
 concurrently, how to model nested FSMs, etc., will be discussed. 

Author recommends you to follow steps described in this document (especially
the first section of it)  with your hands. The procedure might look complicated
initially, but once you try it, you should notice it's designed intuitive and straightforward
(at least the author tried very hard to make it intuitive and straightforward).

# Modeling FSM
Let's model your FSM. If you are creating a finite state machine which has two actions, 
```cook``` and ```eat```, and only after ```cook``` is done, the machine can ```eat``` 
a thing, a state transition diagram for it would be like following.

[Figure 1. Simplest finite state machine]
```
                               
                                +--+
                                |  |eat 
                                |  V 
    +-----+                   +------+
    |  I  |------------------>|COOKED|
    +-----+       cook        +------+


```

The machine has 2 states, which are ```I``` and ```COOKED```. ```I``` is the initial 
state in which the machine is right after its creation. And ```COOKED``` is the 
state to which it moves after an action ```cook``` is performed.

If you are going to implement this state machine as a Java program, it might become like this,

[Code 1. Implementation of Figure 1 - SUT with a bug.]
```java
    
    public class FSMonster {
        boolean cooked = false;
        public void cook() {
            // Don't we need to check the value of cooked before assigning?
            this.cooked = true;
        }
       
        public void eat() {
            if (this.cooked) {
                System.out.println("Yummy!");
            } else {
                throw new IllegalStateException("Not yet cooked!");
            }
        }
    }

```

What should happen if ```cook``` is attempted when the machine is already in ```COOKED``` state?
Unless explicitly described in the state machine diagram, shouldn't it be rejected?

Yes, it should be rejected. This is an intentional bug for explanation of "FSM support
feature". This bug itself might be easy to be found, but if you have some experience in
software developments, finding/debugging this sort of bugs is sometimes a time consuming,
cumbersome, boring task.

How to detect this sort of bugs in your SUT using "FSM feature" of JCUnit will be
discussed later in this document.


## Listing states and actions
Let's go back to the diagram [Figure. 1], as we already saw, there are 2 states and 2 actions,

* States: ```I```, ```COOKED```
* Actions(Input symbols): ```cook```, ```eat```

In JCUnit, to model a finite state machine, you need to implement ```FSMSpec<SUT>```
interface. ```SUT``` is a class name of your software under test.
And inside your implementation, you will use a few annotations, ```@StateSpec```, ```@ActionSpec```,
and ```@ParameterSpec```. Only first two will be necessary to model the machine 
and ```@ParameterSpec``` will be discussed later to model an action with parameters.

```public static final``` fields annotated with ```@StateSpec``` will be treated 
as states by JCUnit.
Among those fields, a field named ```I``` (capital I) has a special semantics, where
it is considered 'initial state' of the finite state machine. And you must define
it always.

Methods annotated with ```@ActionSpec``` are treated as definitions of actions.
They must return ```Expectation<SUT>``` and their first parameter must be ```Expectation.Builder<SUT>``` 
always.
JCUnit validates the types and complain if they do not meet the requirements.

Following is a skeleton of the spec of the FSM.


[Code 2. Model in JCUnit of Figure 1 - Skeleton]
```java

    public enum Spec implements FSMSpec<FSMonster> {
      @StateSpec I {
        ... },
      @StateSpec COOKED {
        ... },; 

      @ActionSpec public Expectation<FSMonster> cook(Expectation.Builder<FSMonster> b) {
        ... }
      @ActionSpec public Expectation<FSMonster> eat(Expectation.Builder<FSMonster> b) {
        ... }
    }

```

## Modeling states and actions
Mathematically, a (deterministic) finite state machine (transducer) can be formalized 
as follows

```

      Sigma: input symbols
      Gamma: output symbols
      S:     states
      s0:    initial state
      delta: state transition function. delta: S x Sigma -> S
      omega: output function. omega: S x Sigma -> Gamma (Mealy machine)

```

We have already created an ```enum``` class, ```Spec```. This so far modeled ```S```,
```s0```, and ```Sigma```.
```S``` is represented by enum fields annotated with ```@StateSpec```. ```s0``` 
is ```I```. ```Sigma``` is modeled as methods annotated with ```@ActionSpec```.

In this sub section, how we can model the rest of them, which are ```Gamma```,
  ```delta```, and ```omega``` will be discussed.

About ```Gamma```, since JCUnit is a software product to test Java programmes,
we need to consider exceptions as output symbols not only regular returned values.

And about ```Sigma```, since methods in Java have parameters, we somehow need to 
take them into considerations. This topic will also be covered in this sub-section.

### Modeling states
At first, FSMSpec<SUT> interface requires you to implement ```check(SUT): boolean``` 
method. The method is responsible for checking if the SUT is in the specified state.
Suppose that ```FSMonster``` has a method ```isReady()```, which returns true iff it's
in ```COOKED``` state, you can do following

[Code 3. Implementing states]
```java

    public enum Spec implements FSMSpec<FSMonster> {
      @StateSpec I {
        @Override public boolean check(FlyingSpaghettiMonster fsm) {
          return !fsm.isReady();
        }
      },
      @StateSpec COOKED {
        @Override public boolean check(FlyingSpaghettiMonster fsm) {
          return fsm.isReady();
        }
      },;
      ...
    }

```

If there is not an easy (and safe) way to check it, simply you can return ```true```
always like following.

```java

    public enum Spec implements FSMSpec<FSMonster> {
      ...
      public boolean check(FSMonster fsm) {
          return true.
      }
    }

```

Without making sure the SUT is in expected state, should we really return OK?
Yes, it's inevitable.

If the SUT has ```getState()```, it would be good to write something like following,

```java

    @StateSpec I {
      @Override public boolean check(FlyingSpaghettiMonster fsm) {
        return "Initial".equals(fsm.getState().getName());
      }
    },
    @StateSpec COOKED {
      @Override public boolean check(FlyingSpaghettiMonster fsm) {
        return "Cooked".equals(fsm.getState().getName());
      }
    },;

```

But it is not necessarily the case always, and more importantly the FSM we modeled
first (fig. 1) is independent of its actual implementation. Even if "getState()"
method is provided, is the method really giving a correct state always? Isn't it
what we are very testing?
Yes, if it is giving a state different from expectation, the SUT might be actually
in wrong state. Or it might be a bug where it is not giving a correct state. Either
way, we can say that it's a bug. Therefore, it's a good idea to check if the returned
state is correct.
But even if it is giving an expected state, it might be just deceiving us. What
we can do here is to check SUT's state if it violates any known constraints derived
from its specification at most.
Of course, if there is a very good way to make sure if and only if the SUT is in the state,
you should implement it in the 'check' method.


## Modeling actions
As we already mentioned, if it is not explicitly allowed in a state machine diagram,
we should think that an operation isn't allowed.

In the figure 1., operations allowed are 'cook' on state 'I', and 'eat' on 'COOKED'.
Therefore, we should test if 'eat' on 'I' and 'cook' on 'COOKED' result in errors.

[Figure 1. Simplest finite state machine]
```
                               
                                +--+
                                |  |eat 
                                |  V 
    +-----+                   +------+
    |  I  |------------------>|COOKED|
    +-----+       cook        +------+


```

The idea that 'unless it is explicitly allowed, it should result in an error' can
be expressed in a following way.

[Code 4. Implementing actions (1) Defining default behaviours]
```java

    public enum Spec implements FSMSpec<FSMonster> {
      ...
      @ActionSpec public Expectation<FSMonster> cook(Expectation.Builder<FSMonster> b) {
        return b.invalid().build();
      }
      @ActionSpec public Expectation<FSMonster> eat(Expectation.Builder<FSMonster> b) {
        return b.invalid().build();
      }
    }
    
```

The parameter ```b``` is an instance of ```Expectation.Builder<SUT>```, by which
you can instantiate ```Expectation<SUT>```. In this case you are creating an expectation
where this operation should fail (```invalid```).

And then you will override these methods in the states accordingly.

[Code 5. Implementing actions (2) Defining state specific behaviours]
```java

    public enum Spec implements FSMSpec<FSMonster> {
      @StateSpec I {
        @Override public boolean check(FlyingSpaghettiMonster fsm) {
          return !fsm.isReady();
        }
        @Override public Expectation<FSMonster> cook(Expectation.Builder<FSMonster> b) {
          return b.valid(COOKED).build();
        }
      },
      @StateSpec COOKED {
        @Override public boolean check(FlyingSpaghettiMonster fsm) {
          return fsm.isReady();
        }
        @Override public Expectation<FSMonster> eat(Expectation.Builder<FSMonster> b) {
          return b.valid(COOKED).build();
        }
      },;
     
      @ActionSpec public Expectation<FSMonster> cook(Expectation.Builder<FSMonster> b) {
        return b.invalid().build();
      }
      @ActionSpec public Expectation<FSMonster> eat(Expectation.Builder<FSMonster> b) {
        return b.invalid().build();
      }
    }

```

### Testing values returned by methods
In the example above, we are only able to test SUT's states. But methods can return 
values. And they must be tested. 

To test a returned value by a method, you need to describe your expectation for SUT.
You can do it by giving it to ```Expectation.Builder```.

If a method ```cook()``` of ```FSMonster``` should be returning a string ```"Cooking spaghetti"```,
then you can do this.

```java


    public enum Spec implements FSMSpec<FSMonster> {
      @StateSpec I {
        ...
        @Override public Expectation<FSMonster> cook(Expectation.Builder<FSMonster> b) {
          return b.valid(COOKED, CoreMatchers.startsWith("Cooking")).build();
        }
      },
      ...

```

The method ```valid(FSMSpec<SUT>, Matcher)``` of the builder sets expected status 
of the SUT and a condition to be satisfied by the value returned by the method ```cook``` of SUT,
 in this example ```FSMonster```.
The ```Matcher``` and ```CoreMatchers``` in this example are from ```org.hamcrest``` 
library, which is used in JUnit itself.

### About the finite state machine model we are using
As you may noticed, you can test a method which returns a different value when the
state machine is in a different state.

```java


    public enum Spec implements FSMSpec<FSMonster> {
      @StateSpec I {
        ...
        @Override public Expectation<FSMonster> cook(Expectation.Builder<FSMonster> b) {
          return b.valid(COOKED, CoreMatchers.startsWith("Cooking a dish")).build();
        }
      },
      @StateSpec COOKED {
        ...
        @Override public Expectation<FSMonster> cook(Expectation.Builder<FSMonster> b) {
          return b.valid(COOKED, CoreMatchers.startsWith("Cooking another dish")).build();
        }
      },
      ...

```

This is one sort of transducers called 'Mealy machine'. Its mathematical model can be
formalized as follows.

```

      Sigma: input symbols
      Gamma: output symbols
      S:     states
      s0:    initial state
      delta: state transition function. delta: S x Sigma -> S
      omega: output function. omega: S x Sigma -> Gamma (Mealy machine)
```

You can refer to Wikipedia articles for definitions of the models ([Mealy Machine][1]
and [Finite state transducer][2]).

## Annotations to model FSM
Following is a matrix that summarizes specifications of annotations used to model
FSMs.

| Annotation     | Target  | Modifiers           | Type                   |
| -------------- |:-------:|:------------------- |:----------------------:|
| @StateSpec     | Field   | public static final | Enclosing class        |
| @ActionSpec    | Method  | public              | Expectation&lt;SUT&gt; |
| @ParameterSpec | Field   | public static final | Object[][]             |

A list of behaviours of those annotations follows. 

* **```@StateSpec```**: Enclosing class of a field annotated by this must implement
an interface ```FSMSpec<SUT>```. If you want to define a behaviour of an action 
which can be seen on a specific state, you can define a method (which is defined
in the enclosing class and annotated with ```@ActionSpec```)
* **```@ActionSpec```**: The name of the method must be the same as the name of
the method you are going to model by it. The first parameter must be ```Expectation.Builder<SUT>```.
And the rest of the parameters must exactly be the same as ones of the method 
to be tested in SUT.
* **```@ParameterSpec```**: A field annotated with this defines arguments given 
to a method which has the same name as it. The first argument will be picked up from
 the first array,  the second argument will be from the second array.
This manner will be followed to the last element, respectively.

### Testing a method with parameters
Methods have parameters. JCUnit has another annotation ```@ParameterSpec``` to define 
arguments given to actions that represent methods.

```
                               
                                +--+
                                |  |eat 
                                |  V 
    +-----+                   +------+
    |  I  |------------------>|COOKED|
    +-----+ cook(pasta,sauce) +------+


```

If a method ```cook``` has 2 parameters ```pasta``` and ```sauce```, they can be 
modeled as following.

```java

    public enum Spec implements FSMSpec<FSMonster> {
      @StateSpec I {...},
      @StateSpec COOKED {...},;
    
      @ActionSpec public Expectation<FSMonster> cook(Expectation.Builder<FSMonster> b,
          String pasta,
          String sauce) { ... }
      @ParametersSpec
      public static final Object[][] cook = new Object[][] {
          { "spaghetti", "spaghettini", "penne" },
          { "peperoncino", "carbonara", "meat sauce" },
      };
      @ActionSpec public Expectation<FSMonster> eat(Expectation.Builder<FSMonster> b) {
        ... }
    }

```

You can define arguments that should be given to a method ```cook``` as a public
static final field whose name is the same as the method.

```java

      @ParametersSpec public static final Object[][] cook = new Object[][] {
          { "spaghetti", "spaghettini", "penne" },
          { "peperoncino", "carbonara", "meat sauce" },
      };

```

The type of it must always be ```Object[][]```. And the first element of it should
be an array each of whose elements will be given to the method ```cook``` as its
first argument. Of course the rest of the array will be treated in the same manner.

i.e., for the method ```cook(String,String)```, one of ```{ "spaghetti", "spaghettini", "penne" }```,
e.g., ```penne``` will be picked up and given to ```cook```'s first argument.
For the second parameter, one of ```{ "peperoncino", "carbonara", "meat sauce" }```,
e.g., ```meat sauce``` will be picked up and used as ```cook```'s second parameter.

JCUnit will automatically generates combinations of actual arguments from ```@ParameterSpec```.
Probably you might get concerned if a method has only several parameters each of which
has only several possible values, it results in a thousands of test cases.
But it will not happen usually, because JCUnit applies all-pair techniques here.
The detail will be discussed as a part of explanation for how you can describe 
"test requirements" in JCUnit.
 
### Testing exceptions thrown by methods
Same as returned values, we want to test if a method is throwing an appropriate 
exception. You can do it by writing code as follows,

```java

    public enum Spec implements FSMSpec<FSMonster> {
      @StateSpec I {
        ...
        @Override public Expectation<FSMonster> cook(Expectation.Builder<FSMonster> b) {
          return b.invalid(NullPointerException.class).build();
        }
      },
      ...

```

You can even test if the SUT is in intended state after an exception is thrown.

```java

    public enum Spec implements FSMSpec<FSMonster> {
      @StateSpec I {
        ...
        @Override public Expectation<FSMonster> cook(Expectation.Builder<FSMonster> b) {
          return b.invalid(I, NullPointerException.class).build();
        }
      },
      ...

```

In the example above, JCUnit will test if the method ```cook``` throws ```NullPointerException```
and then test if the SUT (```FSMonster``` object) is in state ```I```.

# Running tests
Now we have modeled the FSM to be tested. Let's generate tests and run them.
If we go back to the diagram in the introduction ([Figure. 0]), what we need to do 
now is to define 'test requirements'(2) and 'IXIT'(3).
  In this section we will first discuss how to define 'IXIT' and then move to 
'test requirements' because FSM/JCUnit has its defaults for 'test requirements'
and users do not need to pay attention to them unless they want to. 

## IXIT
In this sub section, it will be discussed how to let JCUnit generate test cases
and how to execute those test cases.

### ```Story``` object
Let JCUnit know a field to store information about what path on FSM diagram should 
be executed.  

```java

    @FactorField(levelsProvider = FSMLevelsProvider.class)
    public Story<Spec, FSMonster> main;
  
```

```Spec``` is the (enum) class we have modeled our FSM in the previous section.
And ```FSMonster``` is the class of our SUT.
You don't need to initialize this field by yourself, JCUnit will do it for you.

A factor field whose ```levelsProvider``` is ```FSMLevelsProvider``` must be typed
with ```Story<S, SUT>``` where S is a spec class that you defined for the SUT 
```FSMonster``` in the previous section. As other regular factors, the field must 
be public instance member.

In [the next section](#Inside FSM/JCUnit), internal structure of ```Story<S,SUT>```
 object will be discussed in detail but for now you can consider it is just an object
that stores a sequence of events (methods) and expected states after they are given
to the FSM.

### Instantiating a class
JCUnit tests an object, not a class. A user needs to create an object to be tested 
first.

```java

    @Test
    public void test() throws Throwable {
      FlyingSpaghettiMonster sut = new FlyingSpaghettiMonster();
      FSMUtils.performStory(this, "main", sut);
    }
```

## Test requirements
In this subsection, how test requirements, e.g., number of test cases in a test 
suite to be generated, to what extent paths on a SUT's FSM will be covered, etc.,
can be configured in JCUnit will be discussed.

### Switch coverage
In a Japanese book [ソフトウェアテスト技法ドリル(Drills for software testing techniques)][3],
an idea called 'switch coverage' is discussed (pp. 149).

You can specify a number of switches through ```providerParams```.

```java

    @FactorField(levelsProvider = FSMLevelsProvider.class, providerParams = { @Param("2") })
    public Story<Spec, FSMonster> main;
  
```

Shortly to say, if you specify "2" for this parameter, it means 3 actions (at least) 
will be executed from a state chosen by FSM/JCUnit as a starting point in a test 
case. Because during the sequence 2 states are passed through.

By applying combinatorial method to a state machine, FSM/JCUnit generates
 a test suite with relatively a small (manageable) number. And this means not all
the possible paths whose length are the same as the number specified by this
parameter are actually executed unless you are giving the same number as a number
of all the factors FSM/JCUnit internally creates. 

For more details, refer to [Inside FSM/JCUnit](#Inside FSM/JCUnit) section.

### TupleGenerator
 All-pair (or t-wise) test generation can be very time consuming process.
 Some times probably you want to test your SUT more quickly even if you sacrifice
coverage on your FSM.
 In such a situation, you can configure your test class to use ```RandomTupleGenerator```
instead of ```IPO2TupleGenerator```, which is used by default.

```java

    @RunWith(JCUnit.class)
    @TupleGeneration(
        generator = @Generator(value = RandomTupleGenerator.class, params = {@Param("100"), @Param("1")})
    )
    public static class TestClass1 extends TestClass {
    }
```


# Inside FSM/JCUnit
(t.b.d.)

* Switch coverage
* Story/ScenarioSequence/Scenario
* Internal FSM factors

## Internal FSM factors
Suppose your FSM has 3 states and 4 actions. And it's named "myfsm".
And you have configured your test class that the number of switches is 1.
FSM/JCUnit will create following factors internally.

[Figure 2. State machine for example of factor expansion]
```

          pay         drink
      +---------+  +-----------+
      |         |  |           |
      V         |  V           |
    +---+      +----+        +----+
    | I |----->| S0 |------->| S1 |
    +---+ cook +----+eatWith +----+
      |                        A
      |                        |
      +------------------------+
                drink/1

```

And following  is a list of definitions of methods mentioned in the previous diagram.
Values that a tester want to use in tests as arguments of each method are
 given in comments.

```java

    public void drink(String beverage)  // beverage can be "tea" or "coffee"
    public void eatWith(String silver)  // silver can be "fork" or "spoon"
    public void cook(String pasta, String sauce)
                                        // pasta can be "spaghetti", "spaghettini", or "penne"
                                        // sauce can be "peperoncino", "meat sauce", or "carbonara"
    public void pay(int money)          // money can be 10 or 30.

```

A state machine defined above will be translated into a set of factors, shown in 
a following matrix, by FSM/JCUnit. 


| #| Factor               | Levels                                                          |
|-:| -------------------- |:----------------------------------------------------------------|
| 1| FSM:myfsm:state:0    | I, S0, S1                                                       |
| 2| FSM:myfsm:action:0   | cook, drink, eatWith, pay, VOID                                 |
| 3| FSM:myfsm:param:0:0  | 10, 30, "spaghetti", ..., "fork", ..., "tea", "coffee", or VOID |
| 4| FSM:myfsm:param:0:1  | "peperoncino","meat sauce", "carbonara", VOID                   |
| 5| FSM:myfsm:state:0    | I, S0, S1, VOID                                                 |
| 6| FSM:myfsm:action:1   | cook, drink, eatWith, pay, VOID                                 |
| 7| FSM:myfsm:param:1:0  | (see above)                                                     |
| 8| FSM:myfsm:param:1:1  | (see above)                                                     |


# Advanced techniques
(t.b.d.)

* Nested FSM
* Multi-threaded

# Future works
* **Local constraints**: probably we want to define constraints applied to parameters 
  of a method. 
* **Coverage report**: generating test suite which covers all the possible value-pairs
  under complicated constraints is a very time consuming task. Instead, relying on
  random generation and assessing how much possible value pairs are covered might be
  more practical and good enough.
* **Simplify test suite generation**: right now (Sep/2015), FSM/JCUnit chooses states
 not only events as factors. But, except for the first one, states should always be 
 determined by the previous state and an input symbol (event) given to the FSM.
 As discussed in [Introduction to Combinatorial Testing][4] (pp.119), in this situation
 we can exclude them during test suite generation from factors and after the process
 finishes we can append states determined by previous states and input to each test 
 case. By this optimization, we should be able to improve FSM/JCUnit's performance.

# References
* [0] "Wikipedia article about Model-based testing" 
* [1] "Wikipedia article about Mealy machine"
* [2] "Wikipedia article about Finite state transducer"
* [3] "ソフトウェアテスト技法ドリル テスト設計の考え方と実際", 秋山浩一, ISBN97804-8171-9360-5, 日科技連, 2010
* [4] "Introduction to Combinatorial Testing", D. Richard Kuhn, Raghu N. Kacker, Yu Lei, CRC Press, 2013

[0]: https://en.wikipedia.org/wiki/Model-based_testing
[1]: http://en.wikipedia.org/wiki/Mealy_machine
[2]: http://en.wikipedia.org/wiki/Finite_state_transducer
[3]: http://product.rakuten.co.jp/product/915fc02482596e7ebe6a4eec576a553d/
